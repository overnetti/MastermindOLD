# Introduction
Mastermind is a single player puzzle game where players have a limited number of attempts to guess the secret combination. This command line version of Mastermind utilizes a local database (TinyDB) to save player data and level up as the game progresses. The secret combination is generated by the [Random.org API](https://www.random.org/integers/) and can include duplicate numbers. 

The game has 4 difficulty levels, a round timer, score multipliers depending on the difficulty level and round the player is on, a play again feature, data collection on the player's gaming achievements, an executable file for easy launch, and game logs for debugging or gameplay review.

The code for the game logic is located in `mastermind.py` and the project has been packaged into an `.exe` file using `PyInstaller`.

## How To Play
Using the hints given, solve the secret combination of numbers. The computer will tell you whether you have entered the correct digit and whether any of your correct digits are in the correct position. It will not, however, tell you which digit is in the correct position. Create combinations of numbers until you unlock the code. The more codes you unlock, the higher you level up!

## Special Game Features
The game has the following additional features:

1. **Persistent Memory:** The player is able to create an account in order to maintain their game history across sessions, allowing the game to collect data for the leveling system and to analyze a player's win rate. The `db.json` file appears in the dist folder next to the `.exe` file after the player creates an account and starts their first game.
2. **Multiple Difficulty Levels**: The player can play the game in 4 difficulty modes: EasyPeasy, Normal, Hard, and IMPOSSIBRU. All modes have a 30-second timer on each round. EasyPeasy, Normal, and Hard consist of 10 rounds of gameplay. EasyPeasy's maximum random digit is only 5, giving the player a guessing range of 0 to 5 with 4 digit guesses. Normal has a guessing range of 0 to 7 with 4 digit guesses. Hard takes it up a notch with a guessing range of 0 to 9 and 6 digit guesses. Impossibru takes the player to the extreme with a guessing range of 0 to 9, 10 digit guesses, and only 5 total rounds.
3. **Round Timeout:** All rounds across all difficulty modes have a 30-second timer if an input is not received. Games are still counted towards the player's total game count when calculating their win rate.
4. **Leveling:** As the player wins games, their score passes through multipliers depending on which round and which difficulty they win on. This data is then added to the player's total experience, allowing them to level up. Once a player levels up, the experience they need to earn for the next level is increased by 1.5x.
5. **Score Multipliers:** There is a universal round multiplier that decreases as players get into later rounds (round 1 guesses receive a 2x multiplier, round 10 guesses receive a 1.1x multiplier). There is also a difficulty multiplier that increases as the difficulty increases. EasyPeasy's multiplier is 0.5x, Normal is 1x, Hard is 2x, and Impossibru is 4x. These multipliers come on top of a base score of 100, which is allotted upon winning the game.
6. **Play Again**: Players are prompted whether or not they'd like to play again after winning or losing all 10 rounds of the game or during a round timeout mid-game.
7. **Data Analysis:** A players highest score and winning rate are recorded and reported to the player when they win. Each game started is added to the total number of games the player has played in order to calculate their overall win rate.
8. **Executable File:** The game is packaged into a `.exe` file so players do not need to set up a developer environment in order to run the game.
9. **Game Logs:** The generated winning number, user inputs, and the computer's feedback is recorded in the `mastermind.log` file for debugging and review. This file appears in the dist folder next to the `.exe` file once the player starts their first game.

## Thought Process/Code Structure
I began this project by adopting an iterative approach, aiming to achieve basic functionality. However, as the complexity grew, I recognized the necessity of organizing the code using object-oriented programming principles and dynamic variables. As a result, I structured the code into two main classes: the Mastermind class and the Player class.

The Mastermind class serves as the foundation, defining the core functionality of the game, particularly for the Normal difficulty mode. It facilitates the manipulation of various game aspects through attributes initialized within the class. To enhance modularity and readability, functions are methodically separated. This architectural decision enabled seamless implementation of additional features and facilitated the creation of variant game modes for different difficulty levels. Each difficulty mode (EasyPeasy, Normal, Hard, Impossibru) inherits from the Mastermind class, modifying attributes as necessary to accommodate new functionalities.

Upon achieving the core gameplay, I aimed to introduce player data persistence and a leveling system spanning multiple sessions. I began working on the Player class to manage data storage, leveraging TinyDB to save and retrieve player information locally. For data organization, I designated the player's username as the primary key, implementing a sign-in check to retrieve existing player data or create new entries if the player is new. Given the frequent read and write operations, I opted for a NoSQL database due to its seamless implementation and scalability advantages during this development phase.

Preceding the main class implementations, the code configures a log file that allows gameplay review for players and aids developers in debugging. Additionally, an inputWithTimeout function is implemented to take user input and implement a 30-second round timer using threading.

The code concludes with a login function, which verifies the user's login status, creating an account if necessary, and then routes the player to their desired game mode.

## Obstacles Faced
1. During the implementation of the round timer, I researched various modules. Although Python's [inputimeout](https://pypi.org/project/inputimeout/) module appeared promising at the start, it introduced a keystroke bug in the game where pressing backspace during input made the game reprint the input() function. Since further research led me to solutions that would compromise the cross-platform functionality of the game, I decided to ultimately use threading instead.

2. I encountered a complication when prompting the user about continuing the game if the round timed out mid-game. The program would print "Game over" but leave the user facing a blank screen, forcing them to press enter until their cursor reappeared. To address this bug, I created a threading event that would wait for the designated timeout before checking if the input thread was still alive, printing "Game over" if it was, and then ending the input thread. By separating these threads, I was able to terminate the round's input thread in order to make way for the play again input thread. 

## Execution for Players
1. Download GitHub repo
2. Navigate to the dist folder and click the `.exe` to begin the game!

## Dependencies for Developers
1. Python 3.12
2. `python -m pip install requests`
3. `python -m pip install tinydb`
4. `python -m pip install inputimeout`

## Future Improvements/Updates to come
1. Code quality updates, modularization of classes into separate files
2. Attributes in a config file for easier access and reuse
3. Password encryption
4. Local and online multiplayer options
5. Logger module for both delayed and instantaneous debugging messages
